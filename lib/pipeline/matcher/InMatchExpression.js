"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var InMatchExpression = module.exports = function (){

}, klass = InMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 294-294
//         ArrayFilterEntries _arrayEntries;

proto._arrayEntries = undefined;


// File: expression_leaf.h lines: 294-294
//         ArrayFilterEntries _arrayEntries;

proto._arrayEntries = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method InMatchExpression
 * @param
 *
 */
proto.InMatchExpression = function InMatchExpression( /*  MATCH_IN  */ ){
// File: expression_leaf.h lines: 275-274
//         InMatchExpression() : LeafMatchExpression( MATCH_IN ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method _matchesRealElement
 * @param
 *
 */
proto._matchesRealElement = function _matchesRealElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 422-431
//     bool InMatchExpression::_matchesRealElement( const BSONElement& e ) const {
//         if ( _arrayEntries.contains( e ) )
//             return true;
// 
//         for ( unsigned i = 0; i < _arrayEntries.numRegexes(); i++ ) {
//             if ( _arrayEntries.regex(i)->matchesSingleElement( e ) )
//                 return true;
//         }
// 
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method copyTo
 * @param
 *
 */
proto.copyTo = function copyTo( /*  InMatchExpression* toFillIn  */ ){

// File: expression_leaf.cpp lines: 481-483
//     void InMatchExpression::copyTo( InMatchExpression* toFillIn ) const {
//         toFillIn->init( path() );
//         _arrayEntries.copyTo( toFillIn->_arrayEntries );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_leaf.cpp lines: 455-463
//     void InMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << ";$in: TODO ";
//         MatchExpression::TagData* td = getTag();
//         if (NULL != td) {
//             debug << " ";
//             td->debugString(&debug);
//         }
//         debug << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_leaf.cpp lines: 466-472
//     bool InMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
//         const InMatchExpression* realOther = static_cast<const InMatchExpression*>( other );
//         return
//             path() == realOther->path() &&
//             _arrayEntries.equivalent( realOther->_arrayEntries );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getArrayFilterEntries
 * @param
 *
 */
proto.getArrayFilterEntries = function getArrayFilterEntries( /*  */ ){
// File: expression_leaf.h lines: 280-279
//         ArrayFilterEntries* getArrayFilterEntries() { return &_arrayEntries; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getData
 * @param
 *
 */
proto.getData = function getData( /*  */ ){
// File: expression_leaf.h lines: 290-289
//         const ArrayFilterEntries& getData() const { return _arrayEntries; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path  */ ){

// File: expression_leaf.cpp lines: 418-419
//     Status InMatchExpression::init( const StringData& path ) {
//         return initPath( path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 434-452
//     bool InMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         if ( _arrayEntries.hasNull() && e.eoo() )
//             return true;
// 
//         if ( _matchesRealElement( e ) )
//             return true;
// 
//         /*
//         if ( e.type() == Array ) {
//             BSONObjIterator i( e.Obj() );
//             while ( i.more() ) {
//                 BSONElement sub = i.next();
//                 if ( _matchesRealElement( sub ) )
//                     return true;
//             }
//         }
//         */
// 
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){

// File: expression_leaf.cpp lines: 475-478
//     LeafMatchExpression* InMatchExpression::shallowClone() const {
//         InMatchExpression* next = new InMatchExpression();
//         copyTo( next );
//         return next;
//     }



}