"use strict";
var LeafMatchExpression = require('./LeafMatchExpression');

// Autogenerated by cport.py on 2013-09-17 14:37
var InMatchExpression = module.exports = function InMatchExpression(){
	base.call(this);
	this._matchType = 'MATCH_IN';
	this._arrayEntries = new ArrayFilterEntries();
}, klass = InMatchExpression, base =  LeafMatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});

// DEPENDENCIES
var errors = require("../../Errors.js"),
	ErrorCodes = errors.ErrorCodes,
	ArrayFilterEntries = require("./ArrayFilterEntries.js");

// File: expression_leaf.h lines: 294-294
proto._arrayEntries = null;

/**
 *
 * Check if the input element matches a real element
 * @method _matchesRealElement
 * @param e
 *
 */
proto._matchesRealElement = function _matchesRealElement(e) {
	// File: expression_leaf.cpp lines: 422-431
	if(this._arrayEntries.contains(e)) { // array wrapper.... so no e "in" array
		return true;
	}

	for (var i = 0; i < this._arrayEntries.numRegexes(); i++) {
		if(e.match && e.match(this._arrayEntries.regex(i)._regex)) {
			return true;
		} else if (e instanceof RegExp) {
			if(e.toString() == this._arrayEntries.regex(i)._regex.toString()) {
				return true;
			}
		}
	}

	if(typeof(e) == 'undefined') {
		return true; // Every Set contains the Null Set, man.
	}

	return false;
};

/**
 *
 * Copy our array to the input array
 * @method copyTo
 * @param toFillIn
 *
 */
proto.copyTo = function copyTo(toFillIn) {
	// File: expression_leaf.cpp lines: 481-483
	toFillIn.init(this.path());
	this._arrayEntries.copyTo( toFillIn._arrayEntries );
};

/**
 *
 * Writes a debug string for this object
 * @method debugString
 * @param level
 *
 */
proto.debugString = function debugString(level) {
	// File: expression_leaf.cpp lines: 455-463
	return this._debugAddSpace( level ) + this.path() + ";$in: TODO " + (this.getTag() ? this.getTag().debugString() : '') + "\n";
};

/**
 *
 * checks if this expression is == to the other
 * @method equivalent
 * @param other
 *
 */
proto.equivalent = function equivalent(other) {
	// File: expression_leaf.cpp lines: 466-472
	if ( other._matchType != 'MATCH_IN' ) {
		return false;
	}
	return this.path() == other.path() && this._arrayEntries.equivalent( other._arrayEntries );
};

/**
 *
 * Return the _arrayEntries property
 * @method getArrayFilterEntries
 *
 */
proto.getArrayFilterEntries = function getArrayFilterEntries(){
	// File: expression_leaf.h lines: 280-279
	return this._arrayEntries;
};

/**
 *
 * Return the _arrayEntries property
 * @method getData
 *
 */
proto.getData = function getData(){
	// File: expression_leaf.h lines: 290-289
	return this._arrayEntries;
};

/**
 *
 * Initialize the necessary items
 * @method init
 * @param path
 *
 */
proto.init = function init(path) {
	// File: expression_leaf.cpp lines: 418-419
	return this.initPath( path );
};

/**
 *
 * Check if the input element matches
 * @method matchesSingleElement
 * @param e
 *
 */
proto.matchesSingleElement = function matchesSingleElement(e) {
	// File: expression_leaf.cpp lines: 434-452
	if( this._arrayEntries === null && typeof(e) == 'object' && Object.keys(e).length === 0) {
		return true;
	}
	if (this._matchesRealElement( e )) {
		return true;
	}
	/*if (e instanceof Array){
		for (var i = 0; i < e.length; i++) {
			if(this._matchesRealElement( e[i] )) {
				return true;
			}
		}

	}*/
	return false;
};

/**
 *
 * clone this instance to a new one
 * @method shallowClone
 *
 */
proto.shallowClone = function shallowClone(){
	// File: expression_leaf.cpp lines: 475-478
	var e = new InMatchExpression();
	this.copyTo( e );
	return e;
};

