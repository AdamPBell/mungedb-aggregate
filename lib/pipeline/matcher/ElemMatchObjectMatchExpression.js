"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ElemMatchObjectMatchExpression = module.exports = function (){

}, klass = ElemMatchObjectMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_array.h lines: 77-77
//         boost::scoped_ptr<const MatchExpression> _sub;

proto._sub = undefined;


// File: expression_array.h lines: 77-77
//         boost::scoped_ptr<const MatchExpression> _sub;

proto._sub = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ElemMatchObjectMatchExpression
 * @param
 *
 */
proto.ElemMatchObjectMatchExpression = function ElemMatchObjectMatchExpression( /*  ELEM_MATCH_OBJECT  */ ){
// File: expression_array.h lines: 60-59
//         ElemMatchObjectMatchExpression() : ArrayMatchingMatchExpression( ELEM_MATCH_OBJECT ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_array.cpp lines: 106-109
//     void ElemMatchObjectMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << " $elemMatch\n";
//         _sub->debugString( debug, level + 1 );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getChild
 * @param
 *
 */
proto.getChild = function getChild( /*  size_t i  */ ){
// File: expression_array.h lines: 74-73
//         virtual const MatchExpression* getChild( size_t i ) const { return _sub.get(); }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path, const MatchExpression* sub  */ ){

// File: expression_array.cpp lines: 85-87
//     Status ElemMatchObjectMatchExpression::init( const StringData& path, const MatchExpression* sub ) {
//         _sub.reset( sub );
//         return initPath( path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesArray
 * @param
 *
 */
proto.matchesArray = function matchesArray( /*  const BSONObj& anArray, MatchDetails* details  */ ){

// File: expression_array.cpp lines: 90-103
//     bool ElemMatchObjectMatchExpression::matchesArray( const BSONObj& anArray, MatchDetails* details ) const {
//         BSONObjIterator i( anArray );
//         while ( i.more() ) {
//             BSONElement inner = i.next();
//             if ( !inner.isABSONObj() )
//                 continue;
//             if ( _sub->matchesBSON( inner.Obj(), NULL ) ) {
//                 if ( details && details->needRecord() ) {
//                     details->setElemMatchKey( inner.fieldName() );
//                 }
//                 return true;
//             }
//         }
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numChildren
 * @param
 *
 */
proto.numChildren = function numChildren( /*  */ ){
// File: expression_array.h lines: 73-72
//         virtual size_t numChildren() const { return 1; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_array.h lines: 65-68
//         virtual ElemMatchObjectMatchExpression* shallowClone() const {
//             ElemMatchObjectMatchExpression* e = new ElemMatchObjectMatchExpression();
//             e->init(path(), _sub->shallowClone());
//             return e;
//         }




}