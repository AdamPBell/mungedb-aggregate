"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ElemMatchValueMatchExpression = module.exports = function (){

}, klass = ElemMatchValueMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_array.h lines: 108-108
//         std::vector< const MatchExpression* > _subs;

proto._subs = undefined;


// File: expression_array.h lines: 108-108
//         std::vector< const MatchExpression* > _subs;

proto._subs = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ElemMatchValueMatchExpression
 * @param
 *
 */
proto.ElemMatchValueMatchExpression = function ElemMatchValueMatchExpression( /*  ELEM_MATCH_VALUE  */ ){
// File: expression_array.h lines: 82-81
//         ElemMatchValueMatchExpression() : ArrayMatchingMatchExpression( ELEM_MATCH_VALUE ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method _arrayElementMatchesAll
 * @param
 *
 */
proto._arrayElementMatchesAll = function _arrayElementMatchesAll( /*  const BSONElement& e  */ ){

// File: expression_array.cpp lines: 152-157
//     bool ElemMatchValueMatchExpression::_arrayElementMatchesAll( const BSONElement& e ) const {
//         for ( unsigned i = 0; i < _subs.size(); i++ ) {
//             if ( !_subs[i]->matchesSingleElement( e ) )
//                 return false;
//         }
//         return true;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method add
 * @param
 *
 */
proto.add = function add( /*  const MatchExpression* sub  */ ){

// File: expression_array.cpp lines: 132-134
//     void ElemMatchValueMatchExpression::add( const MatchExpression* sub ) {
//         verify( sub );
//         _subs.push_back( sub );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_array.cpp lines: 160-165
//     void ElemMatchValueMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << " $elemMatch\n";
//         for ( unsigned i = 0; i < _subs.size(); i++ ) {
//             _subs[i]->debugString( debug, level + 1 );
//         }
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getChild
 * @param
 *
 */
proto.getChild = function getChild( /*  size_t i  */ ){
// File: expression_array.h lines: 103-102
//         virtual const MatchExpression* getChild( size_t i ) const { return _subs[i]; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path, const MatchExpression* sub  */ ){

// File: expression_array.cpp lines: 121-124
//     Status ElemMatchValueMatchExpression::init( const StringData& path, const MatchExpression* sub ) {
//         init( path );
//         add( sub );
//         return Status::OK();
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesArray
 * @param
 *
 */
proto.matchesArray = function matchesArray( /*  const BSONObj& anArray, MatchDetails* details  */ ){

// File: expression_array.cpp lines: 137-149
//     bool ElemMatchValueMatchExpression::matchesArray( const BSONObj& anArray, MatchDetails* details ) const {
//         BSONObjIterator i( anArray );
//         while ( i.more() ) {
//             BSONElement inner = i.next();
// 
//             if ( _arrayElementMatchesAll( inner ) ) {
//                 if ( details && details->needRecord() ) {
//                     details->setElemMatchKey( inner.fieldName() );
//                 }
//                 return true;
//             }
//         }
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numChildren
 * @param
 *
 */
proto.numChildren = function numChildren( /*  */ ){
// File: expression_array.h lines: 102-101
//         virtual size_t numChildren() const { return _subs.size(); }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_array.h lines: 91-97
//         virtual ElemMatchValueMatchExpression* shallowClone() const {
//             ElemMatchValueMatchExpression* e = new ElemMatchValueMatchExpression();
//             e->init(path());
//             for (size_t i = 0; i < _subs.size(); ++i) {
//                 e->add(_subs[i]->shallowClone());
//             }
//             return e;
//         }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~ElemMatchValueMatchExpression
 * @param
 *
 */
proto.~ElemMatchValueMatchExpression = function ~ElemMatchValueMatchExpression( /*  */ ){

// File: expression_array.cpp lines: 115-118
//     ElemMatchValueMatchExpression::~ElemMatchValueMatchExpression() {
//         for ( unsigned i = 0; i < _subs.size(); i++ )
//             delete _subs[i];
//         _subs.clear();
//     }



}