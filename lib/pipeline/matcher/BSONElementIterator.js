"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var BSONElementIterator = module.exports = function (){

}, klass = BSONElementIterator, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: path.h lines: 140-140
//         ArrayIterationState _arrayIterationState;

proto._arrayIterationState = undefined;


// File: path.h lines: 114-114
//         BSONObj _context;

proto._context = undefined;


// File: path.h lines: 117-117
//         Context _next;

proto._next = undefined;


// File: path.h lines: 113-113
//         const ElementPath& _path;

proto._path = undefined;


// File: path.h lines: 116-115
//         enum State { BEGIN, IN_ARRAY, DONE } _state;

proto._state = undefined;


// File: path.h lines: 142-142
//         boost::scoped_ptr<ElementIterator> _subCursor;

proto._subCursor = undefined;


// File: path.h lines: 143-143
//         boost::scoped_ptr<ElementPath> _subCursorPath;

proto._subCursorPath = undefined;


// File: path.h lines: 140-140
//         ArrayIterationState _arrayIterationState;

proto._arrayIterationState = undefined;


// File: path.h lines: 114-114
//         BSONObj _context;

proto._context = undefined;


// File: path.h lines: 117-117
//         Context _next;

proto._next = undefined;


// File: path.h lines: 113-113
//         const ElementPath& _path;

proto._path = undefined;


// File: path.h lines: 116-115
//         enum State { BEGIN, IN_ARRAY, DONE } _state;

proto._state = undefined;


// File: path.h lines: 142-142
//         boost::scoped_ptr<ElementIterator> _subCursor;

proto._subCursor = undefined;


// File: path.h lines: 143-143
//         boost::scoped_ptr<ElementPath> _subCursorPath;

proto._subCursorPath = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method BSONElementIterator
 * @param
 *
 */
proto.BSONElementIterator = function BSONElementIterator( /*  const ElementPath& path, const BSONObj& context  */ ){

// File: path.cpp lines: 77-80
//     BSONElementIterator::BSONElementIterator( const ElementPath& path, const BSONObj& context )
//         : _path( path ), _context( context ) {
//         _state = BEGIN;
//         //log() << "path: " << path.fieldRef().dottedField() << " context: " << context << endl;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method more
 * @param
 *
 */
proto.more = function more( /*  */ ){

// File: path.cpp lines: 120-230
//     bool BSONElementIterator::more() {
//         if ( _subCursor ) {
// 
//             if ( _subCursor->more() )
//                 return true;
// 
//             _subCursor.reset();
// 
//             if ( _arrayIterationState.isArrayOffsetMatch( _arrayIterationState._current.fieldName() ) ) {
//                 if ( _arrayIterationState.nextEntireRest() ) {
//                     _next.reset( _arrayIterationState._current, _arrayIterationState._current, true );
//                     _arrayIterationState._current = BSONElement();
//                     return true;
//                 }
// 
//                 _subCursorPath.reset( new ElementPath() );
//                 _subCursorPath->init( _arrayIterationState.restOfPath.substr( _arrayIterationState.nextPieceOfPath.size() + 1 ) );
//                 _subCursorPath->setTraverseLeafArray( _path.shouldTraverseLeafArray() );
//                 _subCursor.reset( new BSONElementIterator( *_subCursorPath, _arrayIterationState._current.Obj() ) );
//                 _arrayIterationState._current = BSONElement();
//                 return more();
//             }
// 
//         }
// 
//         if ( !_next.element().eoo() )
//             return true;
// 
//         if ( _state == DONE ){
//             return false;
//         }
// 
//         if ( _state == BEGIN ) {
//             size_t idxPath = 0;
//             BSONElement e = getFieldDottedOrArray( _context, _path.fieldRef(), &idxPath );
// 
//             if ( e.type() != Array ) {
//                 _next.reset( e, BSONElement(), false );
//                 _state = DONE;
//                 return true;
//             }
// 
//             // its an array
// 
//             _arrayIterationState.reset( _path.fieldRef(), idxPath + 1 );
// 
//             if ( !_arrayIterationState.hasMore && !_path.shouldTraverseLeafArray() ) {
//                 _next.reset( e, BSONElement(), true );
//                 _state = DONE;
//                 return true;
//             }
// 
//             _arrayIterationState.startIterator( e );
//             _state = IN_ARRAY;
//             return more();
//         }
// 
//         if ( _state == IN_ARRAY ) {
// 
//             while ( _arrayIterationState.more() ) {
// 
//                 BSONElement x = _arrayIterationState.next();
//                 if ( !_arrayIterationState.hasMore ) {
//                     _next.reset( x, x, false );
//                     return true;
//                 }
// 
//                 // i have deeper to go
// 
//                 if ( x.type() == Object ) {
//                     _subCursorPath.reset( new ElementPath() );
//                     _subCursorPath->init( _arrayIterationState.restOfPath );
//                     _subCursorPath->setTraverseLeafArray( _path.shouldTraverseLeafArray() );
// 
//                     _subCursor.reset( new BSONElementIterator( *_subCursorPath, x.Obj() ) );
//                     return more();
//                 }
// 
// 
//                 if ( _arrayIterationState.isArrayOffsetMatch( x.fieldName() ) ) {
// 
//                     if ( _arrayIterationState.nextEntireRest() ) {
//                         _next.reset( x, x, false );
//                         return true;
//                     }
// 
//                     if ( x.isABSONObj() ) {
//                         _subCursorPath.reset( new ElementPath() );
//                         _subCursorPath->init( _arrayIterationState.restOfPath.substr( _arrayIterationState.nextPieceOfPath.size() + 1 ) );
//                         _subCursorPath->setTraverseLeafArray( _path.shouldTraverseLeafArray() );
//                         BSONElementIterator* real = new BSONElementIterator( *_subCursorPath, _arrayIterationState._current.Obj() );
//                         _subCursor.reset( real );
//                         real->_arrayIterationState.reset( _subCursorPath->fieldRef(), 0 );
//                         real->_arrayIterationState.startIterator( x );
//                         real->_state = IN_ARRAY;
//                         _arrayIterationState._current = BSONElement();
//                         return more();
//                     }
//                 }
// 
//             }
// 
//             if ( _arrayIterationState.hasMore )
//                 return false;
// 
//             _next.reset( _arrayIterationState._theArray, BSONElement(), true );
//             _state = DONE;
//             return true;
//         }
// 
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method next
 * @param
 *
 */
proto.next = function next( /*  */ ){

// File: path.cpp lines: 233-241
//     ElementIterator::Context BSONElementIterator::next() {
//         if ( _subCursor ) {
//             Context e = _subCursor->next();
//             e.setArrayOffset( _arrayIterationState._current );
//             return e;
//         }
//         Context x = _next;
//         _next.reset();
//         return x;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~BSONElementIterator
 * @param
 *
 */
proto.~BSONElementIterator = function ~BSONElementIterator( /*  */ ){

// File: path.cpp lines: 83-83
//     BSONElementIterator::~BSONElementIterator() {
//     }



}