"use strict";

ElementPath = require('ElementPath');
BSONElement = require('BSONElemtn');
// Autogenerated by cport.py on 2013-09-17 14:37
var BSONElementIterator = module.exports = function ( path, context ){
	// File: path.cpp lines: 77-80 
	this._path = path;
	this._context = context;
	this._state = 'BEGIN';
	//console.debug( 'path: ' + path.fieldRef().dottedField() + ' context: ' + context + '\n');
}, klass = BSONElementIterator, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: path.h lines: 140-140
//         ArrayIterationState _arrayIterationState;

proto._arrayIterationState = undefined;

// File: path.h lines: 117-117
//         Context _next;

proto._next = undefined;

// File: path.h lines: 142-142
//         boost::scoped_ptr<ElementIterator> _subCursor;

proto._subCursor = undefined;


// File: path.h lines: 143-143
//         boost::scoped_ptr<ElementPath> _subCursorPath;

proto._subCursorPath = undefined;


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method more
 * @param
 *
 */
proto.more = function more( /*  */ ){
// File: path.cpp lines: 120-230
	if( this._subCursor ){
		if( this._subCursor.more() ) {return true;}
		this._subCursor.reset();
 
		if ( this._arrayIterationState.isArrayOffsetMatch( this._arrayIterationState._current.fieldName() ) ) {
			if ( this._arrayIterationState.nextEntireRest() ) {
				this._next.reset( this._arrayIterationState._current, this._arrayIterationState._current, true );
				this._arrayIterationState._current = new BSONElement(); //BSON
				return true;
			}

			this._subCursorPath.reset( new ElementPath() );
			this._subCursorPath.init( this._arrayIterationState.restOfPath.substr( this._arrayIterationState.nextPieceOfPath.size() + 1 ) );
			this._subCursorPath.setTraverseLeafArray( this._path.shouldTraverseLeafArray() );
			this._subCursor.reset( new BSONElementIterator( this._subCursorPath, this._arrayIterationState._current.Obj() ) );
			this._arrayIterationState._current = BSONElement();
			return this.more();
		}
 
	}

	if ( !this._next.element().eoo() ) {return true;}

	if ( this._state == 'DONE' ){ return false; }

	if ( this._state == 'BEGIN' ) {
		var idxPath = {pathID:0};
		var e = ElementPath.getFieldDottedOrArray( this._context, this._path.fieldRef(), idxPath ); //BSONElement
		if ( e.type() != Array ) {
			this._next.reset( e, new BSONElement(), false );
			this._state = 'DONE';
			return true;
		}
		// its an array

		this._arrayIterationState.reset( this._path.fieldRef(), idxPath.pathID + 1 );

		if ( !this._arrayIterationState.hasMore && this._path.shouldTraverseLeafArray() ) {
			this._next.reset( e, new BSONElement(), true );
			this._state = 'DONE';
			return true;
		}

		this._arrayIterationState.startIterator( e );
		this._state = IN_ARRAY;
		return more();
	}

	if ( this._state == 'IN_ARRAY' ) {

		while ( this._arrayIterationState.more() ) {
			var x = this._arrayIterationState.next(); //BSONElement
			if ( !this._arrayIterationState.hasMore() ) {
				this._next.reset( x, x, false );
				return true;
			}

			// i have deeper to go

			if ( x.type() == Object ) {
				this._subCursorPath.reset( new ElementPath() );
				this._subCursorPath.init( this._arrayIterationState.restOfPath );
				this._subCursorPath.setTraverseLeafArray( this._path.shouldTraverseLeafArray() );

				this._subCursor.reset( new BSONElementIterator( this._subCursorPath, x.Obj() ) );
				return more();
			}

			if ( this._arrayIterationState.isArrayOffsetMatch( x.fieldName() ) ) {

				if ( this._arrayIterationState.nextEntireRest() ) {
					this._next.reset( x, x, false );
					return true;
				}
	
				if ( x.isABSONObj() ) {
					this._subCursorPath.reset( new ElementPath() );
					this._subCursorPath.init( this._arrayIterationState.restOfPath.substr( this._arrayIterationState.nextPieceOfPath.size() + 1 ) );
					this._subCursorPath.setTraverseLeafArray( this._path.shouldTraverseLeafArray() );
					var real = new BSONElementIterator( this._subCursorPath, this._arrayIterationState._current.Obj() );
					this._subCursor.reset( real );
					real._arrayIterationState.reset( this._subCursorPath.fieldRef(), 0 );
					real._arrayIterationState.startIterator( x );
					real._state = 'IN_ARRAY';
					this._arrayIterationState._current = new BSONElement();
					return more();
				}
			}

		}
		if ( this._arrayIterationState.hasMore() ) { return false; }
		
		this._next.reset( this._arrayIterationState._theArray, new BSONElement(), true );
		this._state = 'DONE';
		return true;
	}
	return false;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method next
 * @param
 *
 */
proto.next = function next(){
// File: path.cpp lines: 233-241

	if ( this._subCursor ) {
		var e = this._subCursor.next(); //Context
		e.setArrayOffset( this._arrayIterationState._current );
		return e;
	}
	var x = _next; //Context
	this._next.reset();
	return x;
};

