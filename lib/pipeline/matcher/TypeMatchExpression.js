"use strict";
var MatchExpression = require('./MatchExpression');
var ElementPath = require('./ElementPath');

// Autogenerated by cport.py on 2013-09-17 14:37
var TypeMatchExpression = module.exports = function TypeMatchExpression(){
	base.call(this);
	this._elementPath = new ElementPath();
	this._matchType = 'TYPE_OPERATOR';
}, klass = TypeMatchExpression, base =  MatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 338-338
proto._elementPath = undefined;

// File: expression_leaf.h lines: 337-337
proto._path = undefined;

// File: expression_leaf.h lines: 339-339
proto._type = undefined;

/**
 *
 * Writes a debug string for this object
 * @method debugString
 * @param level
 *
 */
proto.debugString = function debugString(level) {
	// File: expression_leaf.cpp lines: 335-343
	return this._debugAddSapce( level ) + this.path() + " type: " + this._type + (this.getTag() ? this.getTag().debugString() : '' ) + "\n";
};

/**
 *
 * checks if this expression is == to the other
 * @method equivalent
 * @param other
 *
 */
proto.equivalent = function equivalent(other) {
	// File: expression_leaf.cpp lines: 347-352
	if( other._matchType != 'TYPE_OPERATOR' ) {
		return false;
	}
	return this._path == other._path && this._type == other._type;
};

/**
 *
 * Return the _type property
 * @method getData
 *
 */
proto.getData = function getData(){
	// File: expression_leaf.h lines: 328-327
	return this._type;
};

/**
 *
 * Initialize the necessary items
 * @method init
 * @param path
 * @param type
 *
 */
proto.init = function init(path,type) {
	// File: expression_leaf.cpp lines: 308-311
	this._path = path;
	this._type = type;
	return this._elementPath.init( path );
};

/**
 *
 * matches checks the input doc against the internal element path to see if it is a match
 * @method matches
 * @param doc
 * @param details
 *
 */
proto.matches = function matches(doc,details) {
	// File: expression_leaf.cpp lines: 318-332
	var self = this,
		checker = function(element) {
			if (!this.matchesSingleElement(element, details))
				return false;

			//var amIRoot = (element.length === 0);

			if (details && details.needRecord()) {
				details.setElemMatchKey(element);
			}
			return true;
		};
	return this._elementPath._matches(doc, details, checker);
};

/**
 * Return a number indicating the type of the input element
 * @method typeNumber
 * @param e
 *
 */
klass.typeNumber = function typeNumber(e){
	if(e === undefined)
		return 6;
	if(e === null)
		return 10;
	if(typeof(e) == 'number')
		return 1;
	if(typeof(e) == 'string')
		return 2;
	if(typeof(e) == 'boolean')
		return 8;
	if(typeof(e) == 'object') {
		if(e instanceof Array)
			return 4;
		if(e instanceof RegExp)
			return 11;
		if(e instanceof Date)
			return 9;
		if(e.constructor.name == 'MinKey')
			return -1;
		if(e.constructor.name == 'MAxKey')
			return 127;
	}
	return 42; // Can't tell
};

/**
 *
 * Check if the input element matches
 * @method matchesSingleElement
 * @param e
 *
 */
proto.matchesSingleElement = function matchesSingleElement(e) {
	// File: expression_leaf.cpp lines: 314-315
	return klass.typeNumber( e ) == this._type;
};

/**
 *
 * return the internal path
 * @method path
 *
 */
proto.path = function path(){
	// File: expression_leaf.h lines: 330-329
	return this._path;
};

/**
 *
 * clone this instance to a new one
 * @method shallowClone
 *
 */
proto.shallowClone = function shallowClone(){
	// File: expression_leaf.h lines: 311-314
	var e = new TypeMatchExpression();
	e.init( this._path,this._type );
	return e;
};

