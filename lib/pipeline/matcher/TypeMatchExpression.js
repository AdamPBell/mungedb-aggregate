"use strict";

var MatchExpression = require('./MatchExpression');
var ElementPath = require('./ElementPath');

// Autogenerated by cport.py on 2013-09-17 14:37
var TypeMatchExpression = module.exports = function TypeMatchExpression(){
	base.call(this);
	this._elementPath = new ElementPath();
	this._matchType = 'TYPE_OPERATOR';
}, klass = TypeMatchExpression, base =  MatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 338-338
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_leaf.h lines: 337-337
//         StringData _path;

proto._path = undefined;


// File: expression_leaf.h lines: 339-339
//         int _type;

proto._type = undefined;

/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( level ) {  //  StringBuilder& debug, int level
// File: expression_leaf.cpp lines: 335-343
	return this._debugAddSapce( level ) + this.path() + " type: " + this._type + (this.getTag() ? this.getTag().debugString() : '' ) + "\n";
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( other ) { //  const MatchExpression* other
// File: expression_leaf.cpp lines: 347-352
	if( other._matchType != 'TYPE_OPERATOR' ) {
		return false;
	}
	return this._path == other._path && this._type == other._type;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getData
 * @param
 *
 */
proto.getData = function getData( /*  */ ){
// File: expression_leaf.h lines: 328-327
	return this._type;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( path,type ) { //  const StringData& path, int type
// File: expression_leaf.cpp lines: 308-311
	this._path = path;
	this._type = type;
	return this._elementPath.init( path );
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
/*
proto.matches = function matches( doc,details ) { //  const MatchableDocument* doc, MatchDetails* details
// File: expression_leaf.cpp lines: 318-332
//     bool TypeMatchExpression::matches( const MatchableDocument* doc, MatchDetails* details ) const {
//         boost::scoped_ptr<ElementIterator> cursor( doc->getIterator( _elementPath ) );
//         while ( cursor->more() ) {
//             ElementIterator::Context e = cursor->next();
//             if ( e.outerArray() )
//                 continue;
// 
//             if ( !matchesSingleElement( e.element() ) )
//                 continue;
//             if ( details && details->needRecord() && !e.arrayOffset().eoo() ) {
//                 details->setElemMatchKey( e.arrayOffset().fieldName() );
//             }
//             return true;
//         }
//         return false;
//     }
	var tDoc = ElementPath.objAtPath( doc, this._path );



};*/

klass.typeNumber = function typeNumber( e ){
	if(e === undefined)
		return 6;
	if(e === null)
		return 10;
	if(typeof(e) == 'number')
		return 1;
	if(typeof(e) == 'string')
		return 2;
	if(typeof(e) == 'boolean')
		return 8;
	if(typeof(e) == 'object') {
		if(e instanceof Array)
			return 4;
		if(e instanceof Regexp)
			return 11;
		if(e instanceof Date)
			return 9;
		if(e.constructor.name == 'MinKey')
			return -1;
		if(e.construcor.name == 'MAxKey')
			return 127;
	}
	return 42; // Can't tell
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( e ) { //  const BSONElement& e 
// File: expression_leaf.cpp lines: 314-315
	return klass.typeNumber( e ) == this._type;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path( /*  */ ){
// File: expression_leaf.h lines: 330-329
	return this._path();
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 311-314
//         virtual MatchExpression* shallowClone() const {
//             TypeMatchExpression* e = new TypeMatchExpression();
//             e->init(_path, _type);
//             return e;
//         }
	var e = new TypeMatchExpression();
	e.init( this._path,this._type );
	return e;
};

