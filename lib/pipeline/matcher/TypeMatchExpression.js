"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var TypeMatchExpression = module.exports = function (){

}, klass = TypeMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 338-338
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_leaf.h lines: 337-337
//         StringData _path;

proto._path = undefined;


// File: expression_leaf.h lines: 339-339
//         int _type;

proto._type = undefined;


// File: expression_leaf.h lines: 338-338
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_leaf.h lines: 337-337
//         StringData _path;

proto._path = undefined;


// File: expression_leaf.h lines: 339-339
//         int _type;

proto._type = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method TypeMatchExpression
 * @param
 *
 */
proto.TypeMatchExpression = function TypeMatchExpression( /*  TYPE_OPERATOR  */ ){
// File: expression_leaf.h lines: 307-306
//         TypeMatchExpression() : MatchExpression( TYPE_OPERATOR ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_leaf.cpp lines: 335-343
//     void TypeMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << _path << " type: " << _type;
//         MatchExpression::TagData* td = getTag();
//         if (NULL != td) {
//             debug << " ";
//             td->debugString(&debug);
//         }
//         debug << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_leaf.cpp lines: 347-352
//     bool TypeMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         const TypeMatchExpression* realOther = static_cast<const TypeMatchExpression*>( other );
//         return _path == realOther->_path && _type == realOther->_type;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getData
 * @param
 *
 */
proto.getData = function getData( /*  */ ){
// File: expression_leaf.h lines: 328-327
//         int getData() const { return _type; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path, int type  */ ){

// File: expression_leaf.cpp lines: 308-311
//     Status TypeMatchExpression::init( const StringData& path, int type ) {
//         _path = path;
//         _type = type;
//         return _elementPath.init( _path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( /*  const MatchableDocument* doc, MatchDetails* details  */ ){

// File: expression_leaf.cpp lines: 318-332
//     bool TypeMatchExpression::matches( const MatchableDocument* doc, MatchDetails* details ) const {
//         boost::scoped_ptr<ElementIterator> cursor( doc->getIterator( _elementPath ) );
//         while ( cursor->more() ) {
//             ElementIterator::Context e = cursor->next();
//             if ( e.outerArray() )
//                 continue;
// 
//             if ( !matchesSingleElement( e.element() ) )
//                 continue;
//             if ( details && details->needRecord() && !e.arrayOffset().eoo() ) {
//                 details->setElemMatchKey( e.arrayOffset().fieldName() );
//             }
//             return true;
//         }
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 314-315
//     bool TypeMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         return e.type() == _type;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path( /*  */ ){
// File: expression_leaf.h lines: 330-329
//         virtual const StringData path() const { return _path; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 311-314
//         virtual MatchExpression* shallowClone() const {
//             TypeMatchExpression* e = new TypeMatchExpression();
//             e->init(_path, _type);
//             return e;
//         }




}