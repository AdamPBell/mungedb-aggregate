"use strict";

var MatchExpression = require('./MatchExpression');


// Autogenerated by cport.py on 2013-09-17 14:37
var AllElemMatchOp = module.exports = function AllElemMatchOp(){
	base.call(this);
	this._matchType = 'ALL';
}, klass = AllElemMatchOp, base =  MatchExpression , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_array.h lines: 175-175
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_array.h lines: 176-176
//         std::vector< const ArrayMatchingMatchExpression* > _list;

proto._list = undefined;


// File: expression_array.h lines: 174-174
//         StringData _path;

proto._path = undefined;

/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method _allMatch
 * @param
 *
 */
proto._allMatch = function _allMatch( anArray ){ //  const BSONObj& anArray
// File: expression_array.cpp lines: 208-215
	if(this._list.length === 0) { return false; }
	
	for (var i = 0; i < this._list.length; i++) {
		if( ! this._list[i].matchesArray( anArray, null ) ) { return false; }
	}
	
	return true;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method add
 * @param
 *
 */
proto.add = function add( expr ){//  const ArrayMatchingMatchExpression* expr

// File: expression_array.cpp lines: 184-186
//     void AllElemMatchOp::add( const ArrayMatchingMatchExpression* expr ) {
//         verify( expr );
//         _list.push_back( expr );
//     }
	this.verify( expr );
	this._list.append( expr );
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( level ){ //   StringBuilder& debug, int level
// File: expression_array.cpp lines: 219-224
//     void AllElemMatchOp::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << _path << " AllElemMatchOp: " << _path << "\n";
//         for ( size_t i = 0; i < _list.size(); i++ ) {
//             _list[i]->debugString( debug, level + 1);
//         }
//     }
	console.debug(this._debugAddSpace(level) + this._path + " AllElemMatchOp: " + this._path + '\n');
	for (var i = 0; i < this._list.length; i++) {
		this._list[i].debugString(level +1);
	}
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( other ){//  const MatchExpression* other 
// File: expression_array.cpp lines: 227-242
	if (this.matchType() != other.matchType()) {
		return false;
	}

	if( this._path != other._path ) {
		return false;
	}

	if( this._list.length != other._list.length ) {
		return false;
	}
	for (var i = 0; i < this._list.length; i++) {
		if ( !this._list[i].equivalent( other._list[i] ) ) {
			return false;
		}
	}
	return true;
};



/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getChild
 * @param
 *
 */
proto.getChild = function getChild( i ){ //  size_t i
// File: expression_array.h lines: 167-166
	return this._list[i];
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( path ){ //  const StringData& path
// File: expression_array.cpp lines: 177-181
	this._path = path;
	var s = this._elementPath.init( this._path );
	this._elementPath.setTraverseLeafArray( false );
	return s;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( doc,details ) { //  const MatchableDocument* doc, MatchDetails* details

// File: expression_array.cpp lines: 189-198
	var cursor = doc.getIterator( this._elementPath );
	while ( cursor.more ) {
		var e = cursor.next();
		if (e.element().type() != 'Array') {
			continue;
		}
		if (this.all_match(e.element().Obj())) { 
			return true;
		}
	}
	return false;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( e ){ //  const BSONElement& e

// File: expression_array.cpp lines: 201-205
	if ( e instanceof 'Array' ) {
		return false;
	}
	return this._allMatch(e.Obj());
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numChildren
 * @param
 *
 */
proto.numChildren = function numChildren( /*  */ ){
// File: expression_array.h lines: 166-165
	return this._list.length;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path( /*  */ ){
// File: expression_array.h lines: 169-168
	return this._path;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_array.h lines: 145-152
	var e = new AllElemMatchOp();
	e.init( this._path );
	e._list = this._list.slice(0);
	return e;
};

