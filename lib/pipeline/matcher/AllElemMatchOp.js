"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var AllElemMatchOp = module.exports = function (){

}, klass = AllElemMatchOp, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_array.h lines: 175-175
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_array.h lines: 176-176
//         std::vector< const ArrayMatchingMatchExpression* > _list;

proto._list = undefined;


// File: expression_array.h lines: 174-174
//         StringData _path;

proto._path = undefined;


// File: expression_array.h lines: 175-175
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_array.h lines: 176-176
//         std::vector< const ArrayMatchingMatchExpression* > _list;

proto._list = undefined;


// File: expression_array.h lines: 174-174
//         StringData _path;

proto._path = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method AllElemMatchOp
 * @param
 *
 */
proto.AllElemMatchOp = function AllElemMatchOp( /*  ALL  */ ){
// File: expression_array.h lines: 139-138
//         AllElemMatchOp() : MatchExpression( ALL ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method _allMatch
 * @param
 *
 */
proto._allMatch = function _allMatch( /*  const BSONObj& anArray  */ ){

// File: expression_array.cpp lines: 208-215
//     bool AllElemMatchOp::_allMatch( const BSONObj& anArray ) const {
//         if ( _list.size() == 0 )
//             return false;
//         for ( unsigned i = 0; i < _list.size(); i++ ) {
//             if ( !_list[i]->matchesArray( anArray, NULL ) )
//                 return false;
//         }
//         return true;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method add
 * @param
 *
 */
proto.add = function add( /*  const ArrayMatchingMatchExpression* expr  */ ){

// File: expression_array.cpp lines: 184-186
//     void AllElemMatchOp::add( const ArrayMatchingMatchExpression* expr ) {
//         verify( expr );
//         _list.push_back( expr );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_array.cpp lines: 219-224
//     void AllElemMatchOp::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << _path << " AllElemMatchOp: " << _path << "\n";
//         for ( size_t i = 0; i < _list.size(); i++ ) {
//             _list[i]->debugString( debug, level + 1);
//         }
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_array.cpp lines: 227-242
//     bool AllElemMatchOp::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         const AllElemMatchOp* realOther = static_cast<const AllElemMatchOp*>( other );
//         if ( _path != realOther->_path )
//             return false;
// 
//         if ( _list.size() != realOther->_list.size() )
//             return false;
// 
//         for ( unsigned i = 0; i < _list.size(); i++ )
//             if ( !_list[i]->equivalent( realOther->_list[i] ) )
//                 return false;
// 
//         return true;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getChild
 * @param
 *
 */
proto.getChild = function getChild( /*  size_t i  */ ){
// File: expression_array.h lines: 167-166
//         virtual const ArrayMatchingMatchExpression* getChild( size_t i ) const { return _list[i]; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path  */ ){

// File: expression_array.cpp lines: 177-181
//     Status AllElemMatchOp::init( const StringData& path ) {
//         _path = path;
//         Status s = _elementPath.init( _path );
//         _elementPath.setTraverseLeafArray( false );
//         return s;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( /*  const MatchableDocument* doc, MatchDetails* details  */ ){

// File: expression_array.cpp lines: 189-198
//     bool AllElemMatchOp::matches( const MatchableDocument* doc, MatchDetails* details ) const {
//         boost::scoped_ptr<ElementIterator> cursor( doc->getIterator( _elementPath ) );
//         while ( cursor->more() ) {
//             ElementIterator::Context e = cursor->next();
//             if ( e.element().type() != Array )
//                 continue;
//             if ( _allMatch( e.element().Obj() ) )
//                 return true;
//         }
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_array.cpp lines: 201-205
//     bool AllElemMatchOp::matchesSingleElement( const BSONElement& e ) const {
//         if ( e.type() != Array )
//             return false;
// 
//         return _allMatch( e.Obj() );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numChildren
 * @param
 *
 */
proto.numChildren = function numChildren( /*  */ ){
// File: expression_array.h lines: 166-165
//         virtual size_t numChildren() const { return _list.size(); }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path( /*  */ ){
// File: expression_array.h lines: 169-168
//         const StringData path() const { return _path; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_array.h lines: 145-152
//         virtual MatchExpression* shallowClone() const {
//             AllElemMatchOp* e = new AllElemMatchOp();
//             e->init(path());
//             for (size_t i = 0; i < _list.size(); ++i) {
//                 e->add(reinterpret_cast<const ArrayMatchingMatchExpression*>(
//                     _list[i]->shallowClone()));
//             }
//             return e;
//         }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~AllElemMatchOp
 * @param
 *
 */
proto.~AllElemMatchOp = function ~AllElemMatchOp( /*  */ ){

// File: expression_array.cpp lines: 171-174
//     AllElemMatchOp::~AllElemMatchOp() {
//         for ( unsigned i = 0; i < _list.size(); i++ )
//             delete _list[i];
//         _list.clear();
//     }



}