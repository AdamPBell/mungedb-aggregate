"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var WhereMatchExpression = module.exports = function (){

}, klass = WhereMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_where.cpp lines: 55-55
//         string _code;

proto._code = undefined;


// File: expression_where.cpp lines: 59-59
//         ScriptingFunction _func;

proto._func = undefined;


// File: expression_where.cpp lines: 54-54
//         string _ns;

proto._ns = undefined;


// File: expression_where.cpp lines: 58-58
//         auto_ptr<Scope> _scope;

proto._scope = undefined;


// File: expression_where.cpp lines: 56-56
//         BSONObj _userScope;

proto._userScope = undefined;


// File: expression_where.cpp lines: 55-55
//         string _code;

proto._code = undefined;


// File: expression_where.cpp lines: 59-59
//         ScriptingFunction _func;

proto._func = undefined;


// File: expression_where.cpp lines: 54-54
//         string _ns;

proto._ns = undefined;


// File: expression_where.cpp lines: 58-58
//         auto_ptr<Scope> _scope;

proto._scope = undefined;


// File: expression_where.cpp lines: 56-56
//         BSONObj _userScope;

proto._userScope = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method WhereMatchExpression
 * @param
 *
 */
proto.WhereMatchExpression = function WhereMatchExpression( /*  WHERE  */ ){

// File: expression_where.cpp lines: 33-32
//         WhereMatchExpression() : MatchExpression( WHERE ){ _func = 0; }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_where.cpp lines: 113-124
//     void WhereMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << "$where\n";
// 
//         _debugAddSpace( debug, level + 1 );
//         debug << "ns: " << _ns << "\n";
// 
//         _debugAddSpace( debug, level + 1 );
//         debug << "code: " << _code << "\n";
// 
//         _debugAddSpace( debug, level + 1 );
//         debug << "scope: " << _userScope << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_where.cpp lines: 127-134
//     bool WhereMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
//         const WhereMatchExpression* realOther = static_cast<const WhereMatchExpression*>(other);
//         return
//             _ns == realOther->_ns &&
//             _code == realOther->_code &&
//             _userScope == realOther->_userScope;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& ns,$/;" */ ){

// File: expression_where.cpp lines: 62-86
//     Status WhereMatchExpression::init( const StringData& ns,
//                                        const StringData& theCode,
//                                        const BSONObj& scope ) {
// 
//         if ( ns.size() == 0 )
//             return Status( ErrorCodes::BadValue, "ns for $where cannot be empty" );
// 
//         if ( theCode.size() == 0 )
//             return Status( ErrorCodes::BadValue, "code for $where cannot be empty" );
// 
//         _ns = ns.toString();
//         _code = theCode.toString();
//         _userScope = scope.getOwned();
// 
//         NamespaceString nswrapper( _ns );
//         const string userToken = ClientBasic::getCurrent()->getAuthorizationSession()
//                                                           ->getAuthenticatedUserNamesToken();
//         _scope = globalScriptEngine->getPooledScope( nswrapper.db().toString(),
//                                                      "where" + userToken );
//         _func = _scope->createFunction( _code.c_str() );
// 
//         if ( !_func )
//             return Status( ErrorCodes::BadValue, "$where compile error" );
// 
//         return Status::OK();
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( /*  const MatchableDocument* doc, MatchDetails* details  */ ){

// File: expression_where.cpp lines: 89-110
//     bool WhereMatchExpression::matches( const MatchableDocument* doc, MatchDetails* details ) const {
//         verify( _func );
//         BSONObj obj = doc->toBSON();
// 
//         if ( ! _userScope.isEmpty() ) {
//             _scope->init( &_userScope );
//         }
//         _scope->setObject( "obj", const_cast< BSONObj & >( obj ) );
//         _scope->setBoolean( "fullObject" , true ); // this is a hack b/c fullObject used to be relevant
// 
//         int err = _scope->invoke( _func, 0, &obj, 1000 * 60, false );
//         if ( err == -3 ) { // INVOKE_ERROR
//             stringstream ss;
//             ss << "error on invocation of $where function:\n"
//                << _scope->getError();
//             uassert( 16812, ss.str(), false);
//         }
//         else if ( err != 0 ) {   // ! INVOKE_SUCCESS
//             uassert( 16813, "unknown error in invocation of $where function", false);
//         }
// 
//         return _scope->getBoolean( "__returnValue" ) != 0;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_where.cpp lines: 40-41
//         virtual bool matchesSingleElement( const BSONElement& e ) const {
//             return false;
//         }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){

// File: expression_where.cpp lines: 44-47
//         virtual MatchExpression* shallowClone() const {
//             WhereMatchExpression* e = new WhereMatchExpression();
//             e->init(_ns, _code, _userScope);
//             return e;
//         }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~WhereMatchExpression
 * @param
 *
 */
proto.~WhereMatchExpression = function ~WhereMatchExpression( /*  */ ){

// File: expression_where.cpp lines: 34-33
//         virtual ~WhereMatchExpression(){}



}