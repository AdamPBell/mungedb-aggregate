"use strict";

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method WhereMatchExpression
 * @param WHERE
 *
 */
// Autogenerated by cport.py on 2013-09-17 14:37
var WhereMatchExpression = module.exports = function() {
	this._func = 0;
}, klass = WhereMatchExpression, base = Object, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});

// DEPENDENCIES
var errors = require("../../Errors.js"),
	ErrorCodes = errors.ErrorCodes;

// File: expression_where.cpp lines: 55-55
//         string _code;

proto._code = undefined;


// File: expression_where.cpp lines: 59-59
//         ScriptingFunction _func;

proto._func = undefined;


// File: expression_where.cpp lines: 54-54
//         string _ns;

proto._ns = undefined;


// File: expression_where.cpp lines: 58-58
//         auto_ptr<Scope> _scope;

proto._scope = undefined;


// File: expression_where.cpp lines: 56-56
//         BSONObj _userScope;

proto._userScope = undefined;


// File: expression_where.cpp lines: 55-55
//         string _code;

proto._code = undefined;


// File: expression_where.cpp lines: 59-59
//         ScriptingFunction _func;

proto._func = undefined;


// File: expression_where.cpp lines: 54-54
//         string _ns;

proto._ns = undefined;


// File: expression_where.cpp lines: 58-58
//         auto_ptr<Scope> _scope;

proto._scope = undefined;


// File: expression_where.cpp lines: 56-56
//         BSONObj _userScope;

proto._userScope = undefined;

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param debug
 * @param level
 *
 */
proto.debugString = function debugString( debug, level){

// File: expression_where.cpp lines: 113-124
	/*
	proto._debugAddSpace( debug, level );
	debug = debug + "$where\n";

	proto._debugAddSpace( debug, level + 1 );
	debug = debug + "ns: " + proto._ns + "\n";

	proto._debugAddSpace( debug, level + 1 );
	debug = debug + "code: " + proto._code + "\n";

	proto._debugAddSpace( debug, level + 1 );
	debug = debug + "scope: " + proto._userScope + "\n";
	console.log(debug);
	*/

};

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param other
 *
 */
proto.equivalent = function equivalent(other){

// File: expression_where.cpp lines: 127-134
	if ( this.matchType() != other.matchType() ) return false;
	var realOther = new WhereMatchExpression(other);
	return (this._ns == realOther._ns && this._code == realOther._code && this._userScope == realOther._userScope);

};

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param string ns
 * @param theCode
 * @param scope
 *
 */
proto.init = function init(ns, theCode, scope){
	// File: expression_where.cpp lines: 62-86
	if ( ns.size() === 0 )
		return {code:ErrorCodes.BAD_VALUE, description:"ns for $where cannot be empty"};

	if ( theCode.size() === 0 )
		return {code:ErrorCodes.BAD_VALUE, description:"code for $where cannot be empty"};

	this._ns = ns;
	this._code = theCode.toString();
	this._userScope = scope.getOwned();

	// we don't have authentication yet
	// var userToken = ClientBasic::getCurrent().getAuthorizationSession().getAuthenticatedUserNamesToken();

	this._scope = globalScriptEngine.getPooledScope( this._ns.substr(0, this._ns.indexOf('.')), "where" + userToken );
	this._func = this._scope.createFunction( this._code.c_str() );

	if ( !this._func )
		return {code:ErrorCodes.BAD_VALUE, description:"$where compile error"};

	return {code:ErrorCodes.OK};

};

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param doc
 * @param details
 *
 */
proto.matches = function matches(doc /*, details */){
	// File: expression_where.cpp lines: 89-110
	verify( this._func );

	if ( ! this._userScope.isEmpty() ) {
		this._scope.init( this._userScope );
	}
	this._scope.setObject("obj", doc);
	this._scope.setBoolean("fullObject", true); // this is a hack b/c fullObject used to be relevant

	err = this._scope.invoke(this._func, 0, obj, 1000 * 60, false);
	if ( err == -3 ) { // INVOKE_ERROR
		throw new Error("16812 error on invocation of $where function:\n" + this._scope.getError().name);
	}
	else if ( err != 0 ) {   // ! INVOKE_SUCCESS
		throw new Error("16813 unknown error in invocation of $where function");
	}

	return this._scope.getBoolean("__returnValue") != 0;
};

/**
 *
 * WhereMatchExpression never matches a single element
 * @method matchesSingleElement
 * @param e
 *
 */
proto.matchesSingleElement = function matchesSingleElement(e){
	// File: expression_where.cpp lines: 40-41
	return false;
};

/**
 *
 * Create a new WhereMatchExpression and initialize it with our property values
 * @method shallowClone
 *
 */
proto.shallowClone = function shallowClone(){
	// File: expression_where.cpp lines: 44-47
    e = new WhereMatchExpression();
    e.init(this._ns, this._code, this._userScope);
    return e;
};
