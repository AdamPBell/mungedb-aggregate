"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ExistsMatchExpression = module.exports = function (){

}, klass = ExistsMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ExistsMatchExpression
 * @param
 *
 */
proto.ExistsMatchExpression = function ExistsMatchExpression( /*  EXISTS  */ ){
// File: expression_leaf.h lines: 216-215
//         ExistsMatchExpression() : LeafMatchExpression( EXISTS ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_leaf.cpp lines: 286-294
//     void ExistsMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << " exists";
//         MatchExpression::TagData* td = getTag();
//         if (NULL != td) {
//             debug << " ";
//             td->debugString(&debug);
//         }
//         debug << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_leaf.cpp lines: 297-302
//     bool ExistsMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         const ExistsMatchExpression* realOther = static_cast<const ExistsMatchExpression*>( other );
//         return path() == realOther->path();
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path  */ ){

// File: expression_leaf.cpp lines: 278-279
//     Status ExistsMatchExpression::init( const StringData& path ) {
//         return initPath( path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 282-283
//     bool ExistsMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         return !e.eoo();
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 220-223
//         virtual LeafMatchExpression* shallowClone() const {
//             ExistsMatchExpression* e = new ExistsMatchExpression();
//             e->init( path() );
//             return e;
//         }




}