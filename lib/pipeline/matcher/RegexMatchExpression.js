"use strict";

var LeafMatchExpression = require('./LeafMatchExpression');


// Autogenerated by cport.py on 2013-09-17 14:37
var RegexMatchExpression = module.exports = function RegexMatchExpression(){
	base.call(this);
	this._matchType = 'REGEX';
}, klass = RegexMatchExpression, base =  LeafMatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 160-160
//         static const size_t MaxPatternSize = 32764;

klass.MaxPatternSize = 32764;


// File: expression_leaf.h lines: 184-184
//         std::string _flags;

proto._flags = undefined;


// File: expression_leaf.h lines: 185-185
//         boost::scoped_ptr<pcrecpp::RE> _re;

proto._re = undefined;


// File: expression_leaf.h lines: 183-183
//         std::string _regex;

proto._regex = undefined;

/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( level ) { //  StringBuilder& debug, int level
// File: expression_leaf.cpp lines: 225-234
	return this._debugAddSpace( level ) + this.path() + " regex /" + this._regex + "/" + this._flags + (this.getTag() ? ' ' + this.getTag().debugString : '') + "\n";
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( other ) { //  const MatchExpression* other
// File: expression_leaf.cpp lines: 177-185
	return other._matchType == 'REGEX' && this.path() == other.path() && this._regex == other._regex && this._flags == other._flags;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getFlags
 * @param
 *
 */
proto.getFlags = function getFlags( /*  */ ){
// File: expression_leaf.h lines: 180-179
	return this._flags;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getString
 * @param
 *
 */
proto.getString = function getString( /*  */ ){
// File: expression_leaf.h lines: 179-178
	return this._regex;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( path,regex,flags ) { //  const StringData& path, const StringData& regex, const StringData& options
// File: expression_leaf.cpp lines: 196-205
	if(regex.toString().length > klass.MaxPatternSize){
		return {'code':'BAD_VALUE', 'desc':'Regular Expression too long.'};
	}

	this._regex = regex;
	this._flags = flags;
	this._re = new RegExp(regex,flags);
	return this.initPath( path );
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( e ) { //  const BSONElement& e
// File: expression_leaf.cpp lines: 208-222
	return (e.match) && e.match(this._re);
	// No support for SYMBOLS currently
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 167-170
	var e = new RegexMatchExpression();
	e.init( this.path(), this._regex, this._flags );
	return e;
};

