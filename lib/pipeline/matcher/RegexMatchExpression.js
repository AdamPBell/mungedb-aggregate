"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var RegexMatchExpression = module.exports = function (){

}, klass = RegexMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 160-160
//         static const size_t MaxPatternSize = 32764;

proto.MaxPatternSize = undefined;


// File: expression_leaf.h lines: 184-184
//         std::string _flags;

proto._flags = undefined;


// File: expression_leaf.h lines: 185-185
//         boost::scoped_ptr<pcrecpp::RE> _re;

proto._re = undefined;


// File: expression_leaf.h lines: 183-183
//         std::string _regex;

proto._regex = undefined;


// File: expression_leaf.h lines: 160-160
//         static const size_t MaxPatternSize = 32764;

proto.MaxPatternSize = undefined;


// File: expression_leaf.h lines: 184-184
//         std::string _flags;

proto._flags = undefined;


// File: expression_leaf.h lines: 185-185
//         boost::scoped_ptr<pcrecpp::RE> _re;

proto._re = undefined;


// File: expression_leaf.h lines: 183-183
//         std::string _regex;

proto._regex = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method RegexMatchExpression
 * @param
 *
 */
proto.RegexMatchExpression = function RegexMatchExpression( /*  REGEX  */ ){
// File: expression_leaf.h lines: 162-161
//         RegexMatchExpression() : LeafMatchExpression( REGEX ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_leaf.cpp lines: 225-234
//     void RegexMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << " regex /" << _regex << "/" << _flags;
// 
//         MatchExpression::TagData* td = getTag();
//         if (NULL != td) {
//             debug << " ";
//             td->debugString(&debug);
//         }
//         debug << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_leaf.cpp lines: 177-185
//     bool RegexMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         const RegexMatchExpression* realOther = static_cast<const RegexMatchExpression*>( other );
//         return
//             path() == realOther->path() &&
//             _regex == realOther->_regex
//             && _flags == realOther->_flags;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getFlags
 * @param
 *
 */
proto.getFlags = function getFlags( /*  */ ){
// File: expression_leaf.h lines: 180-179
//         const string& getFlags() const { return _flags; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getString
 * @param
 *
 */
proto.getString = function getString( /*  */ ){
// File: expression_leaf.h lines: 179-178
//         const string& getString() const { return _regex; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path, const StringData& regex, const StringData& options  */ ){

// File: expression_leaf.cpp lines: 196-205
//     Status RegexMatchExpression::init( const StringData& path, const StringData& regex, const StringData& options ) {
//         if ( regex.size() > MaxPatternSize ) {
//             return Status( ErrorCodes::BadValue, "Regular expression is too long" );
//         }
// 
//         _regex = regex.toString();
//         _flags = options.toString();
//         _re.reset( new pcrecpp::RE( _regex.c_str(), flags2options( _flags.c_str() ) ) );
// 
//         return initPath( path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 208-222
//     bool RegexMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         //log() << "RegexMatchExpression::matchesSingleElement _regex: " << _regex << " e: " << e << std::endl;
//         switch (e.type()) {
//         case String:
//         case Symbol:
//             // TODO
//             //if (rm._prefix.empty())
//                 return _re->PartialMatch(e.valuestr());
//                 //else
//                 //return !strncmp(e.valuestr(), rm._prefix.c_str(), rm._prefix.size());
//         case RegEx:
//             return _regex == e.regex() && _flags == e.regexFlags();
//         default:
//             return false;
//         }
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 167-170
//         virtual LeafMatchExpression* shallowClone() const {
//             RegexMatchExpression* e = new RegexMatchExpression();
//             e->init( path(), _regex, _flags );
//             return e;
//         }




}