"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ComparisonMatchExpression = module.exports = function (){

}, klass = ComparisonMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 88-88
//         BSONElement _rhs;

proto._rhs = undefined;


// File: expression_leaf.h lines: 88-88
//         BSONElement _rhs;

proto._rhs = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ComparisonMatchExpression
 * @param
 *
 */
proto.ComparisonMatchExpression = function ComparisonMatchExpression( /*  MatchType type  */ ){
// File: expression_leaf.h lines: 71-70
//         ComparisonMatchExpression( MatchType type ) : LeafMatchExpression( type ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_leaf.cpp lines: 135-154
//     void ComparisonMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << " ";
//         switch ( matchType() ) {
//         case LT: debug << "$lt"; break;
//         case LTE: debug << "$lte"; break;
//         case EQ: debug << "=="; break;
//         case GT: debug << "$gt"; break;
//         case GTE: debug << "$gte"; break;
//         default: debug << " UNKNOWN - should be impossible"; break;
//         }
//         debug << " " << _rhs.toString( false );
// 
//         MatchExpression::TagData* td = getTag();
//         if (NULL != td) {
//             debug << " ";
//             td->debugString(&debug);
//         }
// 
//         debug << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_leaf.cpp lines: 53-61
//     bool ComparisonMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( other->matchType() != matchType() )
//             return false;
//         const ComparisonMatchExpression* realOther =
//             static_cast<const ComparisonMatchExpression*>( other );
// 
//         return
//             path() == realOther->path() &&
//             _rhs.valuesEqual( realOther->_rhs );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getData
 * @param
 *
 */
proto.getData = function getData( /*  */ ){
// File: expression_leaf.h lines: 85-84
//         const BSONElement& getData() const { return _rhs; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getRHS
 * @param
 *
 */
proto.getRHS = function getRHS( /*  */ ){
// File: expression_leaf.h lines: 79-78
//         virtual const BSONElement& getRHS() const { return _rhs; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path, const BSONElement& rhs  */ ){

// File: expression_leaf.cpp lines: 65-87
//     Status ComparisonMatchExpression::init( const StringData& path, const BSONElement& rhs ) {
//         _rhs = rhs;
// 
//         if ( rhs.eoo() ) {
//             return Status( ErrorCodes::BadValue, "need a real operand" );
//         }
// 
//         if ( rhs.type() == Undefined ) {
//             return Status( ErrorCodes::BadValue, "cannot compare to undefined" );
//         }
// 
//         switch ( matchType() ) {
//         case LT:
//         case LTE:
//         case EQ:
//         case GT:
//         case GTE:
//             break;
//         default:
//             return Status( ErrorCodes::BadValue, "bad match type for ComparisonMatchExpression" );
//         }
// 
//         return initPath( path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 91-132
//     bool ComparisonMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         //log() << "\t ComparisonMatchExpression e: " << e << " _rhs: " << _rhs << "\n"
//         //<< toString() << std::endl;
// 
//         if ( e.canonicalType() != _rhs.canonicalType() ) {
//             // some special cases
//             //  jstNULL and undefined are treated the same
//             if ( e.canonicalType() + _rhs.canonicalType() == 5 ) {
//                 return matchType() == EQ || matchType() == LTE || matchType() == GTE;
//             }
// 
//             if ( _rhs.type() == MaxKey || _rhs.type() == MinKey ) {
//                 return matchType() != EQ;
//             }
// 
//             return false;
//         }
// 
//         if ( _rhs.type() == Array ) {
//             if ( matchType() != EQ ) {
//                 return false;
//             }
//         }
// 
//         int x = compareElementValues( e, _rhs );
// 
//         //log() << "\t\t" << x << endl;
// 
//         switch ( matchType() ) {
//         case LT:
//             return x < 0;
//         case LTE:
//             return x <= 0;
//         case EQ:
//             return x == 0;
//         case GT:
//             return x > 0;
//         case GTE:
//             return x >= 0;
//         default:
//             fassertFailed( 16828 );
//         }
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~ComparisonMatchExpression
 * @param
 *
 */
proto.~ComparisonMatchExpression = function ~ComparisonMatchExpression( /*  */ ){
// File: expression_leaf.h lines: 75-74
//         virtual ~ComparisonMatchExpression(){}




}