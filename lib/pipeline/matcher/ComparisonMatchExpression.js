"use strict";

var  LeafMatchExpression = require('./LeafMatchExpression');
var Value = require('../Value');

// Autogenerated by cport.py on 2013-09-17 14:37
var ComparisonMatchExpression = module.exports = function ComparisonMatchExpression( type ){
	this._matchType = type;
	return this;
}, klass = ComparisonMatchExpression, base =  LeafMatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 88-88
//         BSONElement _rhs;

proto._rhs = undefined;

/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){
// File: expression_leaf.cpp lines: 135-154
	var retStr = this._debugAddSpace( level ) + this.path() + " ";
	switch (this._matchType){
		case 'LT':
			retStr += '$lt';
			break;
		case 'LTE':
			retStr += '$lte';
			break;
		case 'EQ':
			retStr += '==';
			break;
		case 'GT':
			retStr += '$gt';
			break;
		case 'GTE':
			retStr += '$gte';
			break;
		default:
			retStr += "Unknown comparison!";
			break;
	}

	retStr += this._rhs.toString();
	if (this.getTag() !== null ) {
		retStr += this.getTag().debugString();
	}
	return retStr + '\n';
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( other ) {//  const MatchExpression* other
// File: expression_leaf.cpp lines: 53-61
//     bool ComparisonMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( other->matchType() != matchType() )
//             return false;
//         const ComparisonMatchExpression* realOther =
//             static_cast<const ComparisonMatchExpression*>( other );
// 
//         return
//             path() == realOther->path() &&
//             _rhs.valuesEqual( realOther->_rhs );
//     }
	if (other._matchType != this._matchType) { return false; }
	
	return this.path() == other.path() && Values.compare(this._rhs,other._rhs);

};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getData
 * @param
 *
 */
proto.getData = function getData( /*  */ ){
// File: expression_leaf.h lines: 85-84
	return this._rhs;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getRHS
 * @param
 *
 */
proto.getRHS = function getRHS( /*  */ ){
// File: expression_leaf.h lines: 79-78
	return this._rhs;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( path,rhs ) { //  const StringData& path, const BSONElement& rhs
// File: expression_leaf.cpp lines: 65-87
	this._rhs = rhs;
	if ( rhs === null || (rhs instanceof Object && Object.keys(rhs).length === 0)) { return {'code':'BAD_VALUE', 'desc':'Need a real operand'};}

	if ( rhs === undefined ) { return {'code':'BAD_VALUE', 'desc':'Cannot compare to undefined'};}

	if (!(this._matchType in {"LT":1, "LTE":1, "EQ":1, "GT":1, "GTE":1})) {
		return {'code':'BAD_VALUE', 'desc':'Bad match type for ComparisonMatchExpression'};
	}
	return this.initPath( path );
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( e ){ //  const BSONElement& e
// File: expression_leaf.cpp lines: 91-132	
	if( typeof(e) != typeof(this._rhs) ){
		if ((e === null || e === undefined) && (this._rhs ===null || this._rhs === undefined)) {
			return ["EQ","LTE","GTE"].indexOf(this._matchType) != -1;
		}
	
		if (this._rhs instanceof MaxKey || this._rhs instanceof MinKey) {
			return this._matchType != "EQ";
		}
		return false;
	}

	if( this._rhs instanceof Array) {
		if( this._matchType != 'EQ') {
			return false;
		}
	}
	
	var x = Value.compare( e, this._rhs );
	
	switch( this._matchType ) {
		case "LT":
			return x == -1;
			break;
		case "LTE":
			return x <= 0;
			break;
		case "EQ":
			return x === 0;
			break;
		case "GT":
			return x == 1;
			break;
		case "GTE":
			return x >= 0;
			break;
		default:
			throw new Error("Invalid comparison type evaluated.");
			break;
	}
	return false;
};

