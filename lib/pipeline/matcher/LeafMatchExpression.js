"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var LeafMatchExpression = module.exports = function (){

}, klass = LeafMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 63-63
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_leaf.h lines: 62-62
//         StringData _path;

proto._path = undefined;


// File: expression_leaf.h lines: 63-63
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_leaf.h lines: 62-62
//         StringData _path;

proto._path = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method LeafMatchExpression
 * @param
 *
 */
proto.LeafMatchExpression = function LeafMatchExpression( /*  MatchType matchType  */ ){
// File: expression_leaf.h lines: 46-47
//         LeafMatchExpression( MatchType matchType )
//             : MatchExpression( matchType ) {
//         }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method initPath
 * @param
 *
 */
proto.initPath = function initPath( /*  const StringData& path  */ ){

// File: expression_leaf.cpp lines: 31-33
//     Status LeafMatchExpression::initPath( const StringData& path ) {
//         _path = path;
//         return _elementPath.init( _path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( /*  const MatchableDocument* doc, MatchDetails* details  */ ){

// File: expression_leaf.cpp lines: 37-48
//     bool LeafMatchExpression::matches( const MatchableDocument* doc, MatchDetails* details ) const {
//         boost::scoped_ptr<ElementIterator> cursor( doc->getIterator( _elementPath ) );
//         while ( cursor->more() ) {
//             ElementIterator::Context e = cursor->next();
//             if ( !matchesSingleElement( e.element() ) )
//                 continue;
//             if ( details && details->needRecord() && !e.arrayOffset().eoo() ) {
//                 details->setElemMatchKey( e.arrayOffset().fieldName() );
//             }
//             return true;
//         }
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path( /*  */ ){
// File: expression_leaf.h lines: 56-55
//         virtual const StringData path() const { return _path; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~LeafMatchExpression
 * @param
 *
 */
proto.~LeafMatchExpression = function ~LeafMatchExpression( /*  */ ){
// File: expression_leaf.h lines: 50-49
//         virtual ~LeafMatchExpression(){}




}