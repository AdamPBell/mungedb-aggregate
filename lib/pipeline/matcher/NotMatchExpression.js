"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var NotMatchExpression = module.exports = function (){

}, klass = NotMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_tree.h lines: 152-152
//         boost::scoped_ptr<MatchExpression> _exp;

proto._exp = undefined;


// File: expression_tree.h lines: 152-152
//         boost::scoped_ptr<MatchExpression> _exp;

proto._exp = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method NotMatchExpression
 * @param
 *
 */
proto.NotMatchExpression = function NotMatchExpression( /*  NOT  */ ){
// File: expression_tree.h lines: 118-117
//         NotMatchExpression() : MatchExpression( NOT ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_tree.cpp lines: 146-149
//     void NotMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << "$not\n";
//         _exp->debugString( debug, level + 1 );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_tree.cpp lines: 152-156
//     bool NotMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         return _exp->equivalent( other->getChild(0) );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getChild
 * @param
 *
 */
proto.getChild = function getChild( /*  size_t i  */ ){
// File: expression_tree.h lines: 148-147
//         virtual MatchExpression* getChild( size_t i ) const { return _exp.get(); }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  MatchExpression* exp  */ ){
// File: expression_tree.h lines: 123-125
//         virtual Status init( MatchExpression* exp ) {
//             _exp.reset( exp );
//             return Status::OK();
//         }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( /*  const MatchableDocument* doc, MatchDetails* details = 0  */ ){
// File: expression_tree.h lines: 135-136
//         virtual bool matches( const MatchableDocument* doc, MatchDetails* details = 0 ) const {
//             return !_exp->matches( doc, NULL );
//         }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){
// File: expression_tree.h lines: 139-140
//         virtual bool matchesSingleElement( const BSONElement& e ) const {
//             return !_exp->matchesSingleElement( e );
//         }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numChildren
 * @param
 *
 */
proto.numChildren = function numChildren( /*  */ ){
// File: expression_tree.h lines: 147-146
//         virtual size_t numChildren() const { return 1; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_tree.h lines: 128-132
//         virtual MatchExpression* shallowClone() const {
//             NotMatchExpression* self = new NotMatchExpression();
//             MatchExpression* child = _exp->shallowClone();
//             self->init(child);
//             return self;
//         }




}