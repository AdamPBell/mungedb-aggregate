"use strict";

var Value = require('../Value');

// Autogenerated by cport.py on 2013-09-17 14:37
var ArrayFilterEntries = module.exports = function ArrayFilterEntries(){
	this._hasNull = false;
	this._hasEmptyArray = false;
	this._equalities = [];
	this._regexes = [];
}, klass = ArrayFilterEntries, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 266-266
//         BSONElementSet _equalities;

proto._equalities = undefined;


// File: expression_leaf.h lines: 265-265
//         bool _hasEmptyArray;

proto._hasEmptyArray = undefined;


// File: expression_leaf.h lines: 264-264
//         bool _hasNull; // if _equalities has a jstNULL element in it

proto._hasNull = undefined;


// File: expression_leaf.h lines: 267-267
//         std::vector<RegexMatchExpression*> _regexes;

proto._regexes = undefined;


/**
 *  addEquality
 *
 * @method addEquality
 *
 *
 */
proto.addEquality = function addEquality( e ) {
	//File expression_leaf.cpp lines 369-387

	if(e instanceof Object && Object.keys(e)[0][0] === '$'){
		return {'code':'BAD_VALUE', 'desc':'cannot next $ under $in'};
	}

	if( e instanceof RegExp ) {
		return {'code': 'BAD_VALUE', 'desc':'ArrayFilterEntries equality cannot be a regex'};
	}

	if( e === null ) {
		this._hasNull = true;
	}

	if (e instanceof Array && e.length === 0) {
		this._hasEmptyArray = true;
	}

	this._equalities.push( e );
	return {'code':'OK'};
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method addRegex
 * @param
 *
 */
proto.addRegex = function addRegex( expr ) { //  RegexMatchExpression* expr
// File: expression_leaf.cpp lines: 389-391
	this._regexes.push( expr );
	return {'code':'OK'};
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method contains
 * @param
 *
 */
proto.contains = function contains( elem ) { //  const BSONElement& elem
// File: expression_leaf.h lines: 249-248
	for (var i = 0; i < this._equalities.length; i++) {
		if(typeof(elem) == typeof(this._equalities[i])){
			if(Value.compare(elem, this._equalities[i]) === 0) {
				return true;
			}
		} 
	}
	return false;
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method copyTo
 * @param
 *
 */
proto.copyTo = function copyTo( toFillIn ) { //  ArrayFilterEntries& toFillIn
// File: expression_leaf.cpp lines: 407-412
	toFillIn._hasNull = this._hasNull;
	toFillIn._hasEmptyArray = this._hasEmptyArray;
	toFillIn._equalities = this._equalities;
	toFillIn._regexes = this._regexes.slice(0); // Copy array
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equalities
 * @param
 *
 */
proto.equalities = function equalities( /*  */ ){
// File: expression_leaf.h lines: 248-247
	return this._equalities;
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( other ) { //  const ArrayFilterEntries& other
// File: expression_leaf.cpp lines: 394-404
	if (this._hasNull != other._hasNull) {return false;}
	if (this._regexes.length != other._regexes.length) {return false;}

	for (var i = 0; i < this._regexes.length; i++) {
		if ( !this._regexes[i].equivalent( other._regexes[i] ) ) {
			return false;
		}
	}
	return Value.compare(this._equalities, other._equalities);
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method hasEmptyArray
 * @param
 *
 */
proto.hasEmptyArray = function hasEmptyArray( /*  */ ){
// File: expression_leaf.h lines: 256-255
	return this._hasEmptyArray;
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method hasNull
 * @param
 *
 */
proto.hasNull = function hasNull( /*  */ ){
// File: expression_leaf.h lines: 254-253
	return this._hasNull;
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numRegexes
 * @param
 *
 */
proto.numRegexes = function numRegexes( /*  */ ){
// File: expression_leaf.h lines: 251-250
	return this._regexes.length;
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method regex
 * @param
 *
 */
proto.regex = function regex( idx ) { //  int idx
// File: expression_leaf.h lines: 252-251
	return this._regexes[idx];
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method singleNull
 * @param
 *
 */
proto.singleNull = function singleNull( /*  */ ){
// File: expression_leaf.h lines: 255-254
	return this.size() == 1 && _hasNull;
};


/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method size
 * @param
 *
 */
proto.size = function size( /*  */ ){
// File: expression_leaf.h lines: 257-256
	return this._equalities.length + this._regexes.length;
};

