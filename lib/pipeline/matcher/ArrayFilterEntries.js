"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ArrayFilterEntries = module.exports = function (){

}, klass = ArrayFilterEntries, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 266-266
//         BSONElementSet _equalities;

proto._equalities = undefined;


// File: expression_leaf.h lines: 265-265
//         bool _hasEmptyArray;

proto._hasEmptyArray = undefined;


// File: expression_leaf.h lines: 264-264
//         bool _hasNull; // if _equalities has a jstNULL element in it

proto._hasNull = undefined;


// File: expression_leaf.h lines: 267-267
//         std::vector<RegexMatchExpression*> _regexes;

proto._regexes = undefined;


// File: expression_leaf.h lines: 266-266
//         BSONElementSet _equalities;

proto._equalities = undefined;


// File: expression_leaf.h lines: 265-265
//         bool _hasEmptyArray;

proto._hasEmptyArray = undefined;


// File: expression_leaf.h lines: 264-264
//         bool _hasNull; // if _equalities has a jstNULL element in it

proto._hasNull = undefined;


// File: expression_leaf.h lines: 267-267
//         std::vector<RegexMatchExpression*> _regexes;

proto._regexes = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ArrayFilterEntries
 * @param
 *
 */
proto.ArrayFilterEntries = function ArrayFilterEntries( /*  */ ){

// File: expression_leaf.cpp lines: 358-360
//     ArrayFilterEntries::ArrayFilterEntries(){
//         _hasNull = false;
//         _hasEmptyArray = false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method addEquality
 * @param
 *
 */
proto.addEquality = function addEquality( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 369-386
//     Status ArrayFilterEntries::addEquality( const BSONElement& e ) {
//         if ( e.isABSONObj() ) {
//             if ( e.Obj().firstElement().fieldName()[0] == '$' )
//                 return Status( ErrorCodes::BadValue, "cannot next $ under $in" );
//         }
// 
//         if ( e.type() == RegEx )
//             return Status( ErrorCodes::BadValue, "ArrayFilterEntries equality cannot be a regex" );
// 
//         if ( e.type() == jstNULL ) {
//             _hasNull = true;
//         }
// 
//         if ( e.type() == Array && e.Obj().isEmpty() )
//             _hasEmptyArray = true;
// 
//         _equalities.insert( e );
//         return Status::OK();
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method addRegex
 * @param
 *
 */
proto.addRegex = function addRegex( /*  RegexMatchExpression* expr  */ ){

// File: expression_leaf.cpp lines: 389-391
//     Status ArrayFilterEntries::addRegex( RegexMatchExpression* expr ) {
//         _regexes.push_back( expr );
//         return Status::OK();
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method contains
 * @param
 *
 */
proto.contains = function contains( /*  const BSONElement& elem  */ ){
// File: expression_leaf.h lines: 249-248
//         bool contains( const BSONElement& elem ) const { return _equalities.count(elem) > 0; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method copyTo
 * @param
 *
 */
proto.copyTo = function copyTo( /*  ArrayFilterEntries& toFillIn  */ ){

// File: expression_leaf.cpp lines: 407-412
//     void ArrayFilterEntries::copyTo( ArrayFilterEntries& toFillIn ) const {
//         toFillIn._hasNull = _hasNull;
//         toFillIn._hasEmptyArray = _hasEmptyArray;
//         toFillIn._equalities = _equalities;
//         for ( unsigned i = 0; i < _regexes.size(); i++ )
//             toFillIn._regexes.push_back( static_cast<RegexMatchExpression*>(_regexes[i]->shallowClone()) );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equalities
 * @param
 *
 */
proto.equalities = function equalities( /*  */ ){
// File: expression_leaf.h lines: 248-247
//         const BSONElementSet& equalities() const { return _equalities; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const ArrayFilterEntries& other  */ ){

// File: expression_leaf.cpp lines: 394-404
//     bool ArrayFilterEntries::equivalent( const ArrayFilterEntries& other ) const {
//         if ( _hasNull != other._hasNull )
//             return false;
// 
//         if ( _regexes.size() != other._regexes.size() )
//             return false;
//         for ( unsigned i = 0; i < _regexes.size(); i++ )
//             if ( !_regexes[i]->equivalent( other._regexes[i] ) )
//                 return false;
// 
//         return _equalities == other._equalities;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method hasEmptyArray
 * @param
 *
 */
proto.hasEmptyArray = function hasEmptyArray( /*  */ ){
// File: expression_leaf.h lines: 256-255
//         bool hasEmptyArray() const { return _hasEmptyArray; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method hasNull
 * @param
 *
 */
proto.hasNull = function hasNull( /*  */ ){
// File: expression_leaf.h lines: 254-253
//         bool hasNull() const { return _hasNull; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method numRegexes
 * @param
 *
 */
proto.numRegexes = function numRegexes( /*  */ ){
// File: expression_leaf.h lines: 251-250
//         size_t numRegexes() const { return _regexes.size(); }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method regex
 * @param
 *
 */
proto.regex = function regex( /*  int idx  */ ){
// File: expression_leaf.h lines: 252-251
//         RegexMatchExpression* regex( int idx ) const { return _regexes[idx]; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method singleNull
 * @param
 *
 */
proto.singleNull = function singleNull( /*  */ ){
// File: expression_leaf.h lines: 255-254
//         bool singleNull() const { return size() == 1 && _hasNull; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method size
 * @param
 *
 */
proto.size = function size( /*  */ ){
// File: expression_leaf.h lines: 257-256
//         int size() const { return _equalities.size() + _regexes.size(); }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~ArrayFilterEntries
 * @param
 *
 */
proto.~ArrayFilterEntries = function ~ArrayFilterEntries( /*  */ ){

// File: expression_leaf.cpp lines: 363-366
//     ArrayFilterEntries::~ArrayFilterEntries() {
//         for ( unsigned i = 0; i < _regexes.size(); i++ )
//             delete _regexes[i];
//         _regexes.clear();
//     }



}