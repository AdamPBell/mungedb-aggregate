"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ArrayMatchingMatchExpression = module.exports = function (){

}, klass = ArrayMatchingMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_array.h lines: 55-55
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_array.h lines: 54-54
//         StringData _path;

proto._path = undefined;


// File: expression_array.h lines: 55-55
//         ElementPath _elementPath;

proto._elementPath = undefined;


// File: expression_array.h lines: 54-54
//         StringData _path;

proto._path = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ArrayMatchingMatchExpression
 * @param
 *
 */
proto.ArrayMatchingMatchExpression = function ArrayMatchingMatchExpression( /*  MatchType matchType  */ ){
// File: expression_array.h lines: 36-35
//         ArrayMatchingMatchExpression( MatchType matchType ) : MatchExpression( matchType ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_array.cpp lines: 63-79
//     bool ArrayMatchingMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         const ArrayMatchingMatchExpression* realOther =
//             static_cast<const ArrayMatchingMatchExpression*>( other );
// 
//         if ( _path != realOther->_path )
//             return false;
// 
//         if ( numChildren() != realOther->numChildren() )
//             return false;
// 
//         for ( unsigned i = 0; i < numChildren(); i++ )
//             if ( !getChild(i)->equivalent( realOther->getChild(i) ) )
//                 return false;
//         return true;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method initPath
 * @param
 *
 */
proto.initPath = function initPath( /*  const StringData& path  */ ){

// File: expression_array.cpp lines: 27-31
//     Status ArrayMatchingMatchExpression::initPath( const StringData& path ) {
//         _path = path;
//         Status s = _elementPath.init( _path );
//         _elementPath.setTraverseLeafArray( false );
//         return s;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matches
 * @param
 *
 */
proto.matches = function matches( /*  const MatchableDocument* doc, MatchDetails* details  */ ){

// File: expression_array.cpp lines: 34-53
//     bool ArrayMatchingMatchExpression::matches( const MatchableDocument* doc, MatchDetails* details ) const {
// 
//         boost::scoped_ptr<ElementIterator> cursor( doc->getIterator( _elementPath ) );
// 
//         while ( cursor->more() ) {
//             ElementIterator::Context e = cursor->next();
//             if ( e.element().type() != Array )
//                 continue;
// 
//             bool amIRoot = e.arrayOffset().eoo();
// 
//             if ( !matchesArray( e.element().Obj(), amIRoot ? details : NULL ) )
//                 continue;
// 
//             if ( !amIRoot && details && details->needRecord() && !e.arrayOffset().eoo() ) {
//                 details->setElemMatchKey( e.arrayOffset().fieldName() );
//             }
//             return true;
//         }
//         return false;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_array.cpp lines: 56-59
//     bool ArrayMatchingMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         if ( e.type() != Array )
//             return false;
//         return matchesArray( e.Obj(), NULL );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path( /*  */ ){
// File: expression_array.h lines: 52-51
//         const StringData path() const { return _path; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ~ArrayMatchingMatchExpression
 * @param
 *
 */
proto.~ArrayMatchingMatchExpression = function ~ArrayMatchingMatchExpression( /*  */ ){
// File: expression_array.h lines: 37-36
//         virtual ~ArrayMatchingMatchExpression(){}




}