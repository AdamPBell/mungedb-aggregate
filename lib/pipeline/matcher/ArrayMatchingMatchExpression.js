"use strict";

var MatchExpression = require('./MatchExpression');

// Autogenerated by cport.py on 2013-09-17 14:37
var ArrayMatchingMatchExpression = module.exports = function ArrayMatchingMatchExpression(matchType){
	base.call(this);
	this._matchType = matchType;
	// File: expression_array.h lines: 55-55
	this._elementPath = new ElementPath();
}, klass = ArrayMatchingMatchExpression, base = MatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});

// DEPENDENCIES
var errors = require("../../Errors.js"),
	ErrorCodes = errors.ErrorCodes,
	ElementPath = require('./ElementPath.js');

// File: expression_array.h lines: 54-54
proto._path = undefined;

/**
 *
 * Check if the input element is equivalent to us
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent(other){
	// File: expression_array.cpp lines: 63-79
	if ( this._matchType != other._matchType)
		return false;

	var realOther = new ArrayMatchingMatchExpression(other);

	if (this._path != realOther._path)
		return false;

	if (this.numChildren() != realOther.numChildren())
		return false;

	for (var i = 0; i < this.numChildren(); i++)
		if (!this.getChild(i).equivalent(realOther.getChild(i)))
			return false;
	return true;
};

/**
 *
 * Initialize the input path as our element path
 * @method initPath
 * @param path
 *
 */
proto.initPath = function initPath(path){
	// File: expression_array.cpp lines: 27-31
	this._path = path;
	var status = this._elementPath.init(this._path);
	this._elementPath.setTraverseLeafArray(false);
	return status;
};

/**
 *
 * _matches exists because we don't have pathIterators, so we need a recursive function call
 * through the path pieces
 * @method _matches
 * @param doc
 * @param path
 * @param details
 *
 */
proto._matches = function _matches(doc, path, details){
	// File: expression_array.cpp lines: 34-53
	var element, k, item,
		curr = doc;
	for (k = 0; k < path.length; k++) {
		item = curr[path[k]];
		if (item instanceof Object && item.constructor === Object) {
			curr = item;
			continue;
		} else if (item instanceof Object && item.constructor === Array) {
			if (k == path.length-1) {
				curr = item;
				break; // this is the end of the path, so check this array
			} else if (!(isNaN(parseInt(path[k+1], 10)))) {
				curr = item;
				continue; // the *next* path section is an item in the array so we don't check this whole array
			}
			// otherwise, check each item in the array against the rest of the path
			for(var ii = 0, il = item.length; ii < il; ii++){
				var subitem = item[ii];
				if (subitem.constructor !== Object) continue;	// can't look for a subfield in a non-object value.
				if (this._matches(subitem, path.slice(k), null)) { // check the item against the rest of the path
					if (details && details.needRecord())
						details.setElemMatchKey(ii.toString());
					return true;
				}
			}
			return false; // checked all items in the array and found no matches
		}
	}

	// we got the whole path, now check it
	element = curr;
	if (!(element instanceof Array))
		return false;

	//var amIRoot = (element.length === 0);

	if (!this.matchesArray(element, details))
		return false;

	/*
	if (!amIRoot && details && details.needRecord() {
		details.setElemMatchKey(element);
	}
	*/
	return true;
};


/**
 *
 * matches checks the input doc against the internal path to see if it is a match
 * @method matches
 * @param doc
 * @param details
 *
 */
proto.matches = function matches(doc, details){
	return this._matches(doc, this._elementPath.fieldRef()._array, details);
};

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement(element){
	// File: expression_array.cpp lines: 56-59
	if (!(element instanceof Array))
		return false;
	return this.matchesArray(element, null);
};

/**
 *
 * This documentation was automatically generated. Please update when you touch this function.
 * @method path
 * @param
 *
 */
proto.path = function path(){
	// File: expression_array.h lines: 52-51
	return this._path;
};

/**
 *
 * Check if the input array matches
 * @method path
 * @param anArray
 * @param details
 *
 */
proto.matchesArray = function matchesArray(anArray, details){
	throw new Error("not implemented");
};
