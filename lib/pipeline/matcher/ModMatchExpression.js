"use strict";

var LeafMatchExpression = require('./LeafMatchExpression');

// Autogenerated by cport.py on 2013-09-17 14:37
var ModMatchExpression = module.exports = function ModMatchExpression(){
	base.call(this);
	this._matchType = 'MOD';
}, klass = ModMatchExpression, base =  LeafMatchExpression, proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 210-210
//         int _divisor;

proto._divisor = undefined;


// File: expression_leaf.h lines: 211-211
//         int _remainder;

proto._remainder = undefined;

/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( level ) { //  StringBuilder& debug, int level
// File: expression_leaf.cpp lines: 253-261
	return this._debugAddSpace( level ) + this.path() + " mod " + this._divisor + " % x == " + this._remainder + (this.getTag() ? " " + this.getTag().debugString() : '') + "\n";
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( other ) { //  const MatchExpression* other
// File: expression_leaf.cpp lines: 264-272
	if(other._matchType != 'MOD')
		return false;
	return this.path() == other.path() && this._divisor == other._divisor && this._remainder == other._remainder;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getDivisor
 * @param
 *
 */
proto.getDivisor = function getDivisor( /*  */ ){
// File: expression_leaf.h lines: 206-205
	return this._divisor;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getRemainder
 * @param
 *
 */
proto.getRemainder = function getRemainder( /*  */ ){
// File: expression_leaf.h lines: 207-206
	return this._remainder;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( path,divisor,remainder ) { //  const StringData& path, int divisor, int remainder
// File: expression_leaf.cpp lines: 239-244
	if (divisor === 0 ){
		return {'code':'BAD_VALUE', 'desc':'Divisor cannot be 0'};
	}

	this._divisor = divisor;
	this._remainder = remainder;
	return this.initPath( path );
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( e ) { //  const BSONElement& e 
// File: expression_leaf.cpp lines: 247-250
	if(!(typeof(e) == 'number')) {
		return false;
	}
	
	return (e % this._divisor) == this._remainder;
};


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 194-197
	var e = new ModMatchObject();
	e.init(this.path(),this._divisor, this._remainder);
	return e;
};


