"use strict"



// Autogenerated by cport.py on 2013-09-17 14:37
var ModMatchExpression = module.exports = function (){

}, klass = ModMatchExpression, base =  Object  , proto = klass.prototype = Object.create(base.prototype, {constructor:{value:klass}});


// File: expression_leaf.h lines: 210-210
//         int _divisor;

proto._divisor = undefined;


// File: expression_leaf.h lines: 211-211
//         int _remainder;

proto._remainder = undefined;


// File: expression_leaf.h lines: 210-210
//         int _divisor;

proto._divisor = undefined;


// File: expression_leaf.h lines: 211-211
//         int _remainder;

proto._remainder = undefined;





/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method ModMatchExpression
 * @param
 *
 */
proto.ModMatchExpression = function ModMatchExpression( /*  MOD  */ ){
// File: expression_leaf.h lines: 190-189
//         ModMatchExpression() : LeafMatchExpression( MOD ){}




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method debugString
 * @param
 *
 */
proto.debugString = function debugString( /*  StringBuilder& debug, int level  */ ){

// File: expression_leaf.cpp lines: 253-261
//     void ModMatchExpression::debugString( StringBuilder& debug, int level ) const {
//         _debugAddSpace( debug, level );
//         debug << path() << " mod " << _divisor << " % x == "  << _remainder;
//         MatchExpression::TagData* td = getTag();
//         if (NULL != td) {
//             debug << " ";
//             td->debugString(&debug);
//         }
//         debug << "\n";
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method equivalent
 * @param
 *
 */
proto.equivalent = function equivalent( /*  const MatchExpression* other  */ ){

// File: expression_leaf.cpp lines: 264-272
//     bool ModMatchExpression::equivalent( const MatchExpression* other ) const {
//         if ( matchType() != other->matchType() )
//             return false;
// 
//         const ModMatchExpression* realOther = static_cast<const ModMatchExpression*>( other );
//         return
//             path() == realOther->path() &&
//             _divisor == realOther->_divisor &&
//             _remainder == realOther->_remainder;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getDivisor
 * @param
 *
 */
proto.getDivisor = function getDivisor( /*  */ ){
// File: expression_leaf.h lines: 206-205
//         int getDivisor() const { return _divisor; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method getRemainder
 * @param
 *
 */
proto.getRemainder = function getRemainder( /*  */ ){
// File: expression_leaf.h lines: 207-206
//         int getRemainder() const { return _remainder; }




}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method init
 * @param
 *
 */
proto.init = function init( /*  const StringData& path, int divisor, int remainder  */ ){

// File: expression_leaf.cpp lines: 239-244
//     Status ModMatchExpression::init( const StringData& path, int divisor, int remainder ) {
//         if ( divisor == 0 )
//             return Status( ErrorCodes::BadValue, "divisor cannot be 0" );
//         _divisor = divisor;
//         _remainder = remainder;
//         return initPath( path );
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method matchesSingleElement
 * @param
 *
 */
proto.matchesSingleElement = function matchesSingleElement( /*  const BSONElement& e  */ ){

// File: expression_leaf.cpp lines: 247-250
//     bool ModMatchExpression::matchesSingleElement( const BSONElement& e ) const {
//         if ( !e.isNumber() )
//             return false;
//         return e.numberLong() % _divisor == _remainder;
//     }



}


/**
 * 
 * This documentation was automatically generated. Please update when you touch this function.
 * @method shallowClone
 * @param
 *
 */
proto.shallowClone = function shallowClone( /*  */ ){
// File: expression_leaf.h lines: 194-197
//         virtual LeafMatchExpression* shallowClone() const {
//             ModMatchExpression* m = new ModMatchExpression();
//             m->init( path(), _divisor, _remainder );
//             return m;
//         }




}